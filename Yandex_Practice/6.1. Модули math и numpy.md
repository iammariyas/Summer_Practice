### 1. Математика — круто, но это не точно
Давайте вспомним начало нашего задачника, когда всё было просто: мы не использовали ни циклы, ни коллекции, ни объектно-ориентированное программирование. Перед нами были только входные данные и требовалось предоставить результат.

Напишите программу, которая вычисляет значение функции:

$$f(x)=log_{32}x^\frac{3}{16}+x^{cos\frac{π⋅x}{2⋅e}}−sin^2\frac{x}{π}$$
**Решение:**
```
import math

x = float(input())
a = 3 / 16 * 1 / 5 * math.log2(x)
b = x ** (math.cos((math.pi * x) / (2 * math.e)))
c = math.sin(x / math.pi) ** 2
print(a + b - c)
```
### 2. Потоковый НОД
Напишите программу, находящую наибольшие общие делители для всех переданных в стандартный поток последовательностей чисел.

**Решение:**
```
from sys import stdin
from math import gcd

for line in stdin:
    nums = [int(x) for x in line.strip().split()]
    if nums:
        print(gcd(*nums))
```
### 3. Есть варианты?
Вася пришёл на образовательный семинар и обнаружил, что зрителей на мероприятии — NN, а количество мест — MM.  
Помогите Васе определить вероятность того, что он попадёт на семинар.

**Решение:**
```
from math import comb

n, m = map(int, input().split())
print(comb(n, m) * m // n, comb(n, m))
```
### 4. Среднее не арифметическое
Средним геометрическим нескольких положительных вещественных чисел называют такое число, которым можно заменить каждое из этих чисел так, чтобы их произведение не изменилось.

Формула среднего геометрического для nn чисел выглядит так:

$$G(x_1,x_2,...,x_n)=\sqrt[n]{x_1⋅x_2⋅⋅⋅x_n}=(∏^n_{i=1}x_i)^\frac{1}{n}$$

**Решение:**
```
import math

nums = [float(x) for x in input().split()]
print(math.pow(math.prod(nums), 1 / len(nums)))
```
### 5. Шаг навстречу
Два выдуманных человечка Дека и Поля, пользуются каждый своей системой координат. Деке нравится представлять себя в декартовом пространстве, а Поле — в полярном.

Напишите программу, определяющую кратчайшее расстояние, которое нужно пройти Деке и Поле, чтобы встретиться.

**Решение:**
```
import math

x_1, y_1 = [float(x) for x in input().split()]
radius, angle = [float(x) for x in input().split()]
x_2 = radius * math.cos(angle)
y_2 = radius * math.sin(angle)
print(math.dist((x_1, y_1), (x_2, y_2)))
```
### 6. Матрица умножения
Напишите функцию `multiplication_matrix`, которая принимает размер матрицы $(N)$ и возвращает массив описывающий таблицу умножения $N$ на $N$.

**Решение:**
```
import numpy as np


def multiplication_matrix(n):
	matrix = np.arange(1, n + 1)
	return matrix.reshape(-1, 1) * matrix
```
### 7. Шахматная подготовка
Представьте, что вы пишете компьютерную игру «Шахматы». Вам надо смоделировать шахматную доску, которая представляет собой матрицу. Чёрная клетка представляется нулём, а белая — единицей. Если смотреть на доску сверху, то левая верхняя клетка — белая.

Напишите функцию `make_board`, которая принимает размер шахматной доски, и возвращает матрицу, моделирующую заданную доску.

Установите тип элементов матрицы `int8`.

**Решение:**
```
import numpy as np


def make_board(n):
    a = np.zeros((n, n), dtype=np.int8)
    a[::2, ::2] = 1
    a[1::2, 1::2] = 1
    return a
```
### 8. Числовая змейка 3.0
Когда-то вы помогали детсадовцам с различными змейками. Давайте реализуем её на основе массивов.

Напишите функцию `snake`, которая принимает ширину (MM) и высоту (NN) змейки, а также именованный параметр `direction`.

Параметр `direction` могут принимать значения:

- `H` — горизонтальная змейка, используется по умолчанию;
- `V` — вертикальная змейка.

Функция должна вернуть матрицу, представляющую змейку, с ячейками типа `int16`.

**Решение:**
```
import numpy as np


def snake(m, n, direction='H'):
    if direction == 'H':
        a = np.arange(1, m * n + 1, dtype=np.int16).reshape(n, m)
        a[1::2, :] = a[1::2, ::-1]
    if direction == 'V':
        a = np.arange(1, m * n + 1, dtype=np.int16).reshape(m, n).T
        a[:, 1::2] = a[::-1, 1::2]
    return a
```
### 9. Вращение
Напишите функцию `rotate`, принимающую двумерную матрицу и один из углов поворота: 90°90°, 180°180°, 270°270° и 360°360°.

Функция должна вернуть новую матрицу соответствующую заданному повороту по часовой стрелке.

**Решение:**
```
import numpy as np


def rotate(matrix, angle):
	return np.rot90(matrix, (360 - angle) // 90)
```
### 10. Лесенка
Напишите функцию `stairs`, принимающую вектор и возвращающую матрицу, в которой каждая строка является копией вектора со смещением.

**Решение:**
```
import numpy as np


def stairs(v):
    n = v.shape[0]
    i = (np.arange(n) - np.arange(n).reshape(-1, 1)) % n
    return v[i]

```
