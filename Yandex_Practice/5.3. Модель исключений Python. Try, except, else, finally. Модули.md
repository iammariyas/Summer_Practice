### 1. Обработка ошибок
Вашему решению будет предоставлена функция `func`, которая не имеет параметров и результата. Однако во время её исполнения может произойти одна из ошибок: `ValueError`, `TypeError` или `SystemError`.

Вызовите её, обработайте ошибку и выведите её название. Если ошибка не произойдёт, выведите сообщение "No Exceptions".

**Решение:**
```
try:
    func()
except ValueError:
    print('ValueError')
except TypeError:
    print('TypeError')
except SystemError:
    print('SystemError')
else:
    print('No Exceptions')
```

### 2.  Ломать — не строить
Давайте немного поиграем в «багоюзеров».

Вашему решению будет предоставлена функция `func`, которая принимает два позиционных параметра и производит с ними некую **математическую** операцию.

Предложите вызов функции, который гарантированно породит ошибку внутри функции.

**Решение:**
```
func(None, (1, 2))
```

### 3. Ломать — не строить 2
### 4. Контроль параметров
Напишите функцию `only_positive_even_sum`, которая принимает два параметра и возвращает их сумму.

Если один из параметров не является целым числом, то следует вызвать исключение `TypeError`.  
Если один из параметров не является положительным чётным числом, то следует вызвать исключение `ValueError`.

**Решение:**
```
def only_positive_even_sum(a, b):
    if not any(isinstance(c, int) for c in (a, b)):
        raise TypeError
    if not all(c > 0 and c % 2 == 0 for c in (a, b)):
        raise ValueError
    return a + b
```

### 5. Слияние с проверкой

### 6. Корень зла 2
В одной из первых лекций вы уже решали задачу о поиске корней квадратного уравнения. Давайте модернизируем её.

Напишите функцию `find_roots`, принимающую три параметра: коэффициенты уравнения и возвращающую его корни в виде кортежа из двух значений.

Так же создайте два собственных исключения `NoSolutionsError` и `InfiniteSolutionsError`, которые будут вызваны в случае отсутствия и бесконечного количества решений уравнения соответственно.

Если переданные коэффициенты не являются рациональными числами, вызовите исключение `TypeError`.

**Решение:**
```
class NoSolutionsError(Exception):
    pass


class InfiniteSolutionsError(Exception):
    pass


def find_roots(a, b, c):
    d = b ** 2 - 4 * a * c
    roots = ()
    if not all(isinstance(n, (int, float)) for n in (a, b, c)):
        raise TypeError

    if a == b == c == 0:
        raise InfiniteSolutionsError
    elif a == b == 0:
        raise NoSolutionsError
    elif a == c == 0:
        roots = (0, 0)
    else:
        if a == 0:
            print(-c / b)
        if b == 0:
            if c > 0:
                x1 = (c / a) ** 0.5
                x2 = -((c / a) ** 0.5)
                roots = tuple(sorted([x1, x2]))
            else:
                raise NoSolutionsError
    if a != 0:
        if b == c == 0:
            roots = ((0 / a), (0 / a))
        if d < 0:
            raise NoSolutionsError
        if d == 0:
            roots = (-b / (2 * a), -b / (2 * a))
        if d > 0:
            x1 = (-b + d ** 0.5) / (2 * a)
            x2 = (-b - d ** 0.5) / (2 * a)
            roots = tuple(sorted([x1, x2]))
    return roots
```

### 7. Валидация имени
При регистрации в различных сервисах пользователи вводят большое количество информации. Правильное заполнение полей — важная часть работы программы, поэтому формы снабжают системами валидации данных.

Напишите функцию `name_validation`, которая принимает один позиционный аргумент — фамилию или имя.

Если параметр не является строкой, то вызовите исключение `TypeError`.

А также разработайте собственные ошибки:

- `CyrillicError` — вызывается, если значение не состоит только из кириллических букв;
- `CapitalError` — вызывается, если значение не начинается с заглавной буквы или найдена заглавная буква не в начале значения.

Обработка ошибок должна происходить в порядке, указанном в задании.

В случае успешного выполнения, функция должна вернуть переданный параметр без изменений.

**Решение:**
```
class CyrillicError(Exception):
    pass


class CapitalError(Exception):
    pass


def name_validation(name):
    cyrillic = 'абвгдеёжзийклмнопрстуфхцчшщъыьэюя'
    if not isinstance(name, str):
        raise TypeError
    if not all(s.lower() in cyrillic for s in name):
        raise CyrillicError
    if not name.istitle():
        raise CapitalError
    return name
```
### 8. Валидация имени пользователя
Продолжим реализацию системы валидации.

Напишите функцию `username_validation`, которая принимает один позиционный аргумент — имя пользователя:

Если параметр не является строкой, то вызовите исключение `TypeError`.

А также разработайте собственные ошибки:

- `BadCharacterError` — вызывается, если значение состоит не только из латинских букв, цифр и символа нижнего подчёркивания;
- `StartsWithDigitError` — вызывается, если значение начинается с цифры.

Обработка ошибок должна происходить в порядке, указанном в задании.

В случае успешного выполнения, функция должна вернуть переданный параметр без изменений.

**Решение:**
```
from string import ascii_letters, digits


class BadCharacterError(Exception):
    pass


class StartsWithDigitError(Exception):
    pass


def username_validation(username):
    tmp = f'{ascii_letters}{digits}_'
    if not isinstance(username, str):
        raise TypeError
    if not all(s in tmp for s in username):
        raise BadCharacterError
    if username[0].isdigit():
        raise StartsWithDigitError
    return username
```
### 9. Валидация пользователя
Используйте две предыдущих функции валидации и напишите функцию `user_validation`, которая принимает именованные аргументы:

- `last_name` — фамилия;
- `first_name` — имя;
- `username` — имя пользователя.

Если функции был передан неизвестный параметр или не передан один из обязательных, то вызовите исключение `KeyError`.

Если один из параметров не является строкой, то вызовите исключение `TypeError`.

Обработка данных должна происходить в порядке: фамилия, имя, имя пользователя.

Если поле заполнено верно, функция возвращает словарь с данными пользователя.

**Решение:**
```
from string import ascii_letters, digits


class CyrillicError(Exception):
    pass


class CapitalError(Exception):
    pass


class BadCharacterError(Exception):
    pass


class StartsWithDigitError(Exception):
    pass


def name_validation(name):
    cyrillic = 'абвгдеёжзийклмнопрстуфхцчшщъыьэюя'
    if not isinstance(name, str):
        raise TypeError
    if not all(s.lower() in cyrillic for s in name):
        raise CyrillicError
    if not name.istitle():
        raise CapitalError
    return name


def username_validation(username):
    tmp = f'{ascii_letters}{digits}_'
    if not isinstance(username, str):
        raise TypeError
    if not all(s in tmp for s in username):
        raise BadCharacterError
    if username[0].isdigit():
        raise StartsWithDigitError
    return username


def user_validation(**user):
    if list(user.keys()) != ['last_name', 'first_name', 'username']:
        raise KeyError
    if not all(isinstance(x, str) for x in user.values()):
        raise TypeError

    name_validation(user['last_name'])
    name_validation(user['first_name'])
    username_validation(user['username'])
    return user

```
### 10. Валидация пароля
После того как пользователь ввёл свои данные в требуемом формате, можно позаботиться и о пароле.

Напишите функцию `password_validation`, которая принимает один позиционный параметр — пароль, и следующие именованные параметры:

- `min_length` — минимальная длина пароля, по умолчанию 8;
- `possible_chars` — строка символов, которые могут быть в пароле, по умолчанию латинские буквы и цифры;
- `at_least_one` — функция возвращающая логическое значение, по умолчанию `str.isdigit`.

Если переданный позиционный параметр не является строкой, вызовите исключение `TypeError`.

А так же реализуйте собственные исключения:

- `MinLengthError` — вызывается, если пароль меньше заданной длины;
- `PossibleCharError` — вызывается, если в пароле используется недопустимый символ;
- `NeedCharError` — вызывается, если в пароле не найдено ни одного обязательного символа.

Проверка условий должна происходить в порядке указанном в задании.

Так как, хороший разработчик никогда не хранит пароли в открытом виде, функция, в случае успешного завершения, возвращает хеш пароля. Для этого воспользуйтесь функцией `sha256` из пакета `hashlib` и верните его шестнадцатеричное представление.

**Решение:**
```
from string import ascii_letters, digits
from hashlib import sha256


class MinLengthError(Exception):
    pass


class PossibleCharError(Exception):
    pass


class NeedCharError(Exception):
    pass


symbol = f'{ascii_letters}{digits}'


def password_validation(password, min_length=8, possible_chars=symbol, at_least_one=str.isdigit):
    if not isinstance(password, str):
        raise TypeError
    if len(password) < min_length:
        raise MinLengthError
    if any(i not in possible_chars for i in password):
        raise PossibleCharError
    if not any(at_least_one(x) for x in password):
        raise NeedCharError
    return sha256(password.encode()).hexdigest()
```